To refactor the code provided into a structure that allows calling a method like `motor[x](speed, direction)` and encapsulate PID control and filtering, we need to abstract motor control into a separate function (or even a class if you're looking for a more object-oriented approach). 

Below is an example of how you might refactor the given Arduino code snippet to encapsulate motor speed and direction control, PID updates, and low-pass filtering into reusable functions. This example assumes you're working with some predefined classes or types for motors, PID, and low-pass filters, which your original loop code snippet suggests.

```cpp
class EnhancedMotor {
private:
  Motor* motor; // Assuming `Motor` is a class controlling your motors
  PID* pid;     // Assuming `PID` is a class for your PID controllers
  LowPassFilter* lpFilter; // Assuming you have a low-pass filter class
  float setpoint;
  int lastDirection;
  float output;
  float smoothedRPM;

public:
  EnhancedMotor(Motor* motorObject, PID* pidObject, LowPassFilter* filterObject, float setpointValue) {
    motor = motorObject;
    pid = pidObject;
    lpFilter = filterObject;
    setpoint = setpointValue;
    lastDirection = FORWARD; // Assuming a default direction, FORWARD is a placeholder
    output = 0;
    smoothedRPM = 0;
  }

  void controlMotor(float speed, int direction) {
    updateSpeed(speed);
    updateDirection(direction);
  }

  void updateSpeed(float speed) {
    float rpm = calculateRPM(); // Implement this function based on how you calculate RPM
    smoothedRPM = lpFilter->filt(rpm);
    pid->setInput(smoothedRPM);
    pid->setSetpoint(setpoint);
    pid->compute();
    output = pid->getOutput();
    motor->setSpeed(static_cast<int>(output));
  }

  void updateDirection(int direction) {
    lastDirection = direction;
    motor->run(lastDirection);
  }

private:
  float calculateRPM() {
    // Calculate and return RPM possibly based on encoder counts or other sensor data
    // Placeholder logic
    return 0.0;
  }
};

// Example of usage with four motors
EnhancedMotor* motorControllers[4]; // Assuming initial setup is done elsewhere

void setup() {
  // You need to initialize each motorControllers[i] with actual Motor, PID, and LowPassFilter objects and setpoints
}

void loop() {
  // Example on how you might control a motor
  float desiredSpeed = 100.0; // Example desired speed
  int direction = FORWARD; // Example direction, assuming FORWARD is defined elsewhere

  // Update each motor with the desired speed and direction
  for (int i = 0; i < 4; i++) {
    motorControllers[i]->controlMotor(desiredSpeed, direction);
  } 
  delay(100);
}
```

Please note that this is a base structure to get you started. The actual implementation of calculating RPM (`calculateRPM` method), as well as the initialization and setup of `EnhancedMotor` objects in `setup()`, will significantly depend on your hardware specifics and existing code architecture. The `LowPassFilter`, `Motor`, `PID` classes/interfaces, and the `FORWARD` direction constant must be defined elsewhere in your code, as per your project's architecture.